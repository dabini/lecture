# LIST

## 리스트

- 리스트

  - 순서를 가진 데이터의 집합을 가리키는 추상 자료형

  - 동일한 데이터를 가지고 있어도 상관이 없다

  - 구현 방법

    1) 순차리스트: 배열을 기반으로 구현된 리스트

    2) 연결리스트: 메모리의 동적할당을 기반으로 구현된 리스트

- 순차리스트의 문제점

  - 단순 배열을 이용해 순차리스트를 구현하는 경우, 자료의 삽입/삭제 연산과정에서 연속적인 메모리 배열을 위해 원소들을 이동시키는 작업이 필요하다
  - 원소의 개수가 많고 삽입/삭제 연산이 빈번하게 일어날수록 작업에 소요되는 시간이 크게 증가한다.
  - 배열의 크기가 정해져있는 경우, 실제로 사용될 메모리보다 크게 할당하여 메모리의 낭비를 초래할수도 있고, 반대로 할당된 메모리보다 많은 자료를 사용하여 새롭게 배열을 만들어 작업을 해야하는 경우가 발생할 수도있다.



## 연결리스트

#### 연결리스트

- 특성
  - 자료의 논리적인 순서와 메모리 상의 물리적인 순서가 일치하지 않고, **개별적으로 위치하고 있는 원소의 주소를 연결하여 하나의 전체적인 자료구조**를 이룬다.
  - 링크를 통해 원소에 접근하므로, 순차 리스트에서처럼 **물리적으로 순서를 맞추기 위한 작업이 필요하지 않다.**
  - 자료구조의 크기를 동적으로 조정할 수 있어, **메모리의 효율적인 사용**이 가능하다.

#### 연결 리스트의 기본 구조

- **노드**

  - 연결리스트에서 하나의 원소에 필요한 데이터를 갖고 있는 자료 단위

  - 구성요소

    1) 데이터 필드

    - 원소의 값을 저장하는 자료구조
    - 저장할 원소의 종류나 크기에 따라 구조를 정의하여 사용함

    2) 링크 필드

    - 다음 노드의 주소를 저장하는 자료구조

- 헤드

  - 리스트의 처음 노드를 가리키는 레퍼런스

    head => data|link => data|link

  - 헤드 자체에는 데이터가 저장되지 않음

#### 단순 연결 리스트

- 노드가 하나의 링크 필드에 의해 다음 노드와 연결되는 구조

- 헤드가 가장 앞의 노드를 가리키고, 각 노드의 링크 필드가 연속적으로 다음 노드를 가리킴

- 최종적으로 None을 가리키는 노드가 리스트의 가장 마지막 노드임

- 단순 연결리스트의 삽입 연산

  ```python
  #첫 번째 노드로 삽입하는 알고리즘
  def addtoFirst(data): #첫 노드에 데이터 삽입
      global Head
      HEAD = Node(data, Head) #새로운 노드 생성
  ```

  ```python
  #가운데 노드로 삽입하는 알고리즘
  def add(pre, data): #pre 다음에 데이터 삽입
      if pre == None:
          print('error')
      else:
          pre.link= Node(data, pre.link)
  ```

  ```python
  #마지막 노드로 삽입하는 알고리즘
  def addtoLast(data): #마지막에 데이터 삽입
      global Head
      if Head == None: #빈리스트이면
          Head = Node(data, None)
      else:
          p = Head
          while p.link != None: #마지막 노드를 찾을 때까지
              p = p.link
          p.link = Node(data, None)
  ```

- 단순 연결리스트의 삭제 연산

  ```python
  def deletetoFirst(): #처음 노드 삭제
      global Head
      if Head == None:
          print('error')
      else:
          Head = Head.link
  ```

  ```python
  #노드를 삭제하는 알고리즘
  def delete(pre): #pre 다음 노드 삭제
      if pre == None or pre.link == None:
          print('error')
      else:
          pre.link = pre.link.link
  ```

  - 연결 구조
    - 노드가 하나의 링크 필드에 의해 다음 노드와 연결되는 구조를 가진다.
    - 헤드가 가장 앞의 노드를 가리키고, 링크 필드가 연속적으로 다음 노드를 가리킨다.

    - 최종적으로 NULL을 가리키는 노드가 리스트의 가장 마지막 노드이다.



- 이중연결 리스트
  - 양쪽 방향으로 순회할 수 있도록 노드를 연결한 리스트
  - 두 개의 링크 필드와 한 개의 데이터 필드로 구성



### 삽입정렬

1. 삽입정렬의 특징

   자료 배열의 모든 원소들을 앞에서부터 차례대로 이미 정렬된 부분과 비교하여, 자신의 위치를 찾아냄으로써 정렬을 완성

2. 삽입정렬의 정렬과정

   1) 정렬할 자료를 두 개의 부분집합 S와 U로 가정

   - 부분집합S: 정렬된 앞부분의 원소들
   - 부분집합U: 아직 정렬되지 않은 나머지 원소들

   2) 정렬되지 않은 부분집합 U의 원소를 하나씩 꺼내서 이미 정렬되어있는 부분집합 S의 마지막 원소부터 비교하면서 위치를 찾아 삽입 

   3) 삽입 정렬을 반복하면서 부분집합 S의 원소는 하나씩 늘리고 부분집합 U의 원소는 하나씩 감소하게 함

   4) 부분집합 U가 공집합이 되면 삽입정렬이 완성됨

   

### 병합 정렬

1. 병합 정렬의 특징

   여러개의 정렬된 자료의 집하블 병합하여 한 개의 정렬된 집합으로 만드는 방식

   - 분할 정복 알고리즘 활용
     - 자료를 최소 단위의 문제까지 나눈 후에 차례대로 정렬하여 최종 결과를 얻어냄
     - Top-Down 방식
   - 시간복잡도
     - O(n lon n)

2. 병합 정렬의 과정

   1. 분할 단계: 전체 자료 집합에 대하여, 최소 크기의 부분집합이 될 때까지 분할 작업을 계속함.
   2. 병합 단계: 2개의 부분집합을 정렬하면서 하나의 집합으로 병합



3. 병합 정렬 알고리즘

   1) 분할 과정의 알고리즘

   ```python
   def merge_sort(m):
       if len(m) <= 1: #사이즈가 0이거나 1인 경우, 바로 리턴
           return m
       #1.divide 부분
       mid = len(m)//2
       left = m[:mid]
       right = m[mid:]
   
       # 리스트의 크기가 1이 될 때까지 merge_sort 재귀 호출
       left = merge_sort(left)
       right = merge_sort(right)
   
       #2. Conquer 부분: 분할된 리스트들 병합
       return merge(left, right)
   ```

   

   2) 병합 과정의 알고리즘

   ```python
   def merge(left, right):
       result = [] #두 개의 분할된 리스트를 병합하여 result를 만듦
       
       while len(left) >0 and len(right) >0:
       #양쪽 리스트에 원소가 남은 경우 두 서브 리스트의 첫 원소들을 비교
       #하여 작은 것부터 result에 추가함
       	if left[0] <= right[0]:
               result.append(left.pop(0))
           else:
               result.append(right.pop(0))
       if len(left) >0 : #왼쪽 리스트에 원소가 남아있는 경우
           result.extend(left)
       if len(right) >0: #오른쪽 리스트에 원소가 남아있는 경우
           result.extend(right)
       return result
   ```

   

### Linked List의 활용

1. List를 이용한 Stack
   - 스택의 원소: 리스트의 노드
     - 스택 내의 순서는 리스트의 링크를 통해 연결됨
     - Push: 리스트의 마지막에 노드 사입
     - Pop: 리스트의 마지막 노드 반환/삭제
   - 변수 Top
     - 리스트의 마지막 노드를 가리키는 변수
     - 초기 상태: Top = None

2. List를 이용한 Stack의 연산
   - 리스트를 이용해 Push와 Pop 연산 구현
     1. None 값을 가지는 노드를 만들어 스택 초기화
     2. 원소 A 삽입: push(A)
     3. 원소 B 삽입: push(B)
     4. 원소 C 삽입: push(C)
     5. 원소 반환: pop

3. List를 이용한 Stack의 구현

   Push/Pop 연산의 알고리즘

   ``` python
   def push(i): #원소 i를 스택 top(맨앞) 위치에 push
       global top
       top = Node(i, top)
   def pop():
       global top
       
       if top == None: #빈리스트이면
           print('error')
       else:
           data = top.data
           top = top.link #top이 가리키는 노드를 바꿈
           return data
   ```

4. 우선순위 큐

   - 우선 순위 큐의 구현

     연결 리스트를 이용한 우선순위 큐

   - 우선순위 큐의 기본 연산

     삽입

     삭제

   1) 순차 리스트를 이용한 우선 순위 큐 구현

   - 순차 리스트를 이용하여 자료 저장
   - 원소를 삽입하는 과정에서 우선순위를 비교하여 적절한 위치에 삽입하는 구조
   - 가장 앞에 최고 우선순위의 원소가 위치

   문제점: 배열을 사용하므로, 삽입이나 삭제 연산이 일어날 때 원소의 재배치가 발생함

   이에 소요되는 시간이나 메모리 낭비가 큼

   2) 리스트를 이용한 우선순위 큐 구현

   - 연결 리스트를 이용하여 자료 저장
   - 원소를 삽입한느 과정에서 리스트 내 노드의 원소들과 비교하여 적절한 위치에 노드를 삽입하는 구조
   - 리스트의 가장 앞쪽에 최고 우선순위가 위치하게 됨
   - 배열 대비 장점
     - 삽입 삭제 연산 이후 원소의 재배치가 필요 없고
     - 메모리의 효율적인 사용이 가능

