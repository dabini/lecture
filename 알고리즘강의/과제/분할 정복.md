# 분할 정복

### 1. 거듭제곱

- 반복 알고리즘: O(n)
  - C의 거듭제곱 = 1에 거듭제곱할 값만큼 C를 곱하는 방식으로 연산 수행

    ```python
    def interative_power(C, n):
        result = 1
        for _ in range(n):
            result = result * C
        return result
    ```

    

  - 분할 정복 기반 알고리즘: O(log n)

    ```python
    def recursive_power(C, n):
        if n == 1:
            return C
        if n % 2 == 0:
            y = recursive_power(C, n/2)
            return y * y
        else:
            y = recursive_power(C, n/2)
            return y * y * C
    ```

    

### 2. 병합 정렬(Merge Sort)

- 여러 개의 정렬된 자료의 집합을 병합하여 한 개의 정렬된 집합으로 만드는 방식

- 분할 정복 알고리즘 활용

  - 자료를 최소 단위의 문제까지 나눈 후에 차례대로 정렬하여 최종 결과를 얻어냄
  - top-down 방식

- 시간 복잡도

  - O(nlogn)

- 병합 정렬 과정

  - 분할단계: 전체 자료 집합에 대하여, 최소 크기의 부분집합이 될 때까지 분할 작업을 계속한다.
  - 병합단계: 2개의 부분집합을 정렬하면서 하나의 집합으로 병합
  - 8개의 부분집합이 1개로 병합될 때까지 반복함.

- 알고리즘

  분할과정 수도코드

  ```python
  merge_sort(LIST m):
      if length(m) == 1:
          return m
      LIST left, right
      middle <- length(m) /2
      for x in m before middle
      	add x to left
      for x in m after or equal middle
      	add x to right
      
      left <- merge_sort(left)
      right <- merge_sort(right)
      
      return merge(left, right)
  ```

  

  병합과정 수도코드

  ```python
  merge(LIST left, LIST right)
  	LIST result
      
      WHILE length(left) > 0 OR length(right) >0
      	IF length(left) > 0 AND length(right) > 0
          	IF first(left) <= first(right)
              	append popfirst(left) to result
              ELSE
              	append popfirst(right) to result
          ELIF length(left) > 0
          	append popfirst(left) to result
          ELIF length(right) > 0
          	append popfirst(right) to result
      
      RETURN result
  ```

  

