# 백트래킹

### 1. 백트래킹의 개념

- 여러 가지 선택지들이 존재하는 상황에서 한가지를 선택한다.
- 선택이 이루어지면 새로운 선택지들의 집합이 생성된다.
- 이런 선택을 반복하면서 최종 상태에 도달한다.
  - 올바른 선택을 계속하면 목표 상태에 도달한다.
- 당첨 리프노드 찾기
  - 루트에서 갈 수 있는 노드를 선택한다.
  - 꽝 노드까지 도달하면 최근의 선택으로 되돌아와서 다시 시작한다.
  - 더 이상의 선택지가 없다면 이전의 선택지로 돌아가서 다른 선택을 한다.
  - 루트까지 돌아갔을 경우 더 이상 선택지가 없다면 찾는 답이 없다.



- 백트래킹과 깊이우선탐색의 차이

  - 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로를 따라가지 않음으로써 시도의 횟수를 줄임(prunning)
  - 깊이 우선 탐색이 모든 경로를 추적하는데 비해 백트래킹은 불필요한 경로를 조기에 차단
  - 깊이우선탐색을 가하기에는 경우의 수가 너무나 많음. 즉 n!가지의 경우수를 가진 문제에 대해 깊이 우선 탐색을 가하면 당연히 처리 불가능
  - 백트래킹 알고리즘을 적용하면 일반적으로 경우의 수가 줄어들지만 이 역시 최악의 경우에는 여전히 지수함수 시간을 요하므로 처리 불가능

- 알고리즘 절차

  1. 상태 공간 트리의 깊이우선탐색 실시
  2. 각 노드가 유망한지를 점검
  3. 만일 그 노드가 유망하지 않으면, 그 노드의 부모 노드로 돌아가서 검색을 계속진행

- 수도코드

  ```markdown
  bool backtrack(선택 집합, 선택한 수, 모든 선택 수)
  	if(선택한 수 == 모든 선택수 ) //더이상 탐색할 노드가 없을 경우
  		{
  			찾는 솔루션인지 체크;
  			return 결과;
  		}
  	현재 선택한 상태 집합에 포함되지 않는 후보 선택들(노드) 생성
  	
  	모든 후보 선택들에 대해
  	{
  		선택 집합에 하나의 후보 선택을 추가
  		선택한수 = 선택한 수 +1
  		결과 = backtrack 호출(선택 집합, 선택한수, 모든 선택수)
  		
  		if (결과==성공)
  			return 성공;
  	}
  	return 실패;
  ```

  