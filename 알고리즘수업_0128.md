# 알고리즘

> Algorithm Problem Solving



## 1. 알고리즘

- 알고리즘: 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법이다. 주로 컴퓨터 용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법을 말한다.

- 간단하게 다시 말하면 어떠한 문제를 해결하기 위한 절차라고 볼 수 있다.

- 컴퓨터 분야에서 알고리즘을 표현하는 방법은 크게 두 가지

  

  - 슈더코드(의사코드)

    ![](https://kwonsoonwoo.github.io/assets/cs50/%EC%9D%98%EC%82%AC%EC%BD%94%EB%93%9C%EC%98%88%EC%8B%9C2.png)

    <center>정해진 문법에 맞게 작성할 필요는 없음(문장으로 적기도 함)</center>

  - 순서도

    ![](https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory2&fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F2660153C56951BDE2C24EF)

    <center>알고리즘이 복잡해지면 순서도가 더욱 복잡해짐</center>
<center>-> 주로 슈더코드를 더욱 많이 사용!</center>
    



- APS 과정의 목표 중의 하나는 보다 좋은 알고리즘을 이해하고 활용하는 것이다.

- 무엇이 좋은 알고리즘인가?

  1. **정확성**: 얼마나 정확하게 동작하는가?

  2. **작업량**: 얼마나 적은 연산으로 원하는 결과를 얻어내는가?

  3. **메모리 사용량**: 얼마나 적은 메모리를 사용하는가?

  4. **단순성**: 얼마나 단순한가?

  5. **최적성**: 더 이상 개선할 여지없이 최적화되었는가?

     

#### 알고리즘의 성능은 무엇으로 측정하는가?

- 주어진 문제를 해결하기 위해 여러 개의 다양한 알고리즘 가능

  - 어떤 알고리즘을 사용해야 하는가?

- 알고리즘의 성능 분석 필요

  - 많은 문제에서 성능 분석의 기준으로 알고리즘의 작업량을 비교한다.

  

- 알고리즘의 작업량을 표현할 때 시간복잡도로 표현한다.
- 시간 복잡도( Time Complexity)
  - 실제 걸리는 시간을 측정
  - 실행되는 명령문의 개수를 계산



- 시간 복잡도 = 빅-오(O)표기법
  - 빅-오 표기법(Big Oh Notation)
  - 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시
  - 계수(Coefficient)는 생략하여 표시
  - n개의 데이터를 입력 받아 저장한 후 각 데이터에 1씩 증가시킨 후 각 데이터를 화면에 출력하는 알고리즘의 시간복잡도는 어떻게 되나?
    - O(n)
    - 차수가 가장 큰 n으로 표시
    - 상수로만 표기되어있을 경우 1로 표시





#### 다양한 시간 복잡도의 비교

- 요소 수가 증가함에 따라 각기 다른 시간복잡도의 알고리즘은 아래와 같은 연산 수를 보인다.

![](https://t1.daumcdn.net/cfile/tistory/99275E4D5B78408624)



- 시간복잡도 별 실제 실행 시간 비교

![](https://slidesplayer.org/slide/17510176/102/images/28/%EC%8B%9C%EA%B0%84+%EB%B3%B5%EC%9E%A1%EB%8F%84%EB%B3%84+%EC%8B%A4%EC%A0%9C+%EC%8B%A4%ED%96%89+%EC%8B%9C%EA%B0%84+%EB%B9%84%EA%B5%90+%5B%EA%B0%80%EC%A0%95%5D%EB%8B%A8%EC%9C%84+%EC%97%B0%EC%82%B0+1%ED%9A%8C+%EC%88%98%ED%96%89%EC%8B%9C%EA%B0%84+%3D+10-9+second.jpg)

​		따라서 가능한 nlogn or n2 정도로 알고리즘 짜는 것이 필요



## 2. 배열

![](https://t1.daumcdn.net/cfile/tistory/2636724C5783428411)

<center>자료형</center>

- 배열이란 무엇인가?
  - 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조
    - 묶어주는 이유?  처리 방식을 간소화하기 위해
    - 언어마다 개념이 조금씩 다름
  - 아래의 예는 6개의 변수를 사용해야 하는 경우, 이를 배열로 바꾸어 사용하는 것이다.



​		객체지향언어의 경우 자료형을 갖지 않고, 자료와 처리동작을 하나로 묶어 다루는 객체(object) 개념 도입



- 배열의 필요성
  - 프로그램 내에서 여러 개의 변수가 필요할 때, 일일이 다른 변수명을 이용하여 자료에 접근하는 것은 매우 비효율적일 수 있다.
  - 배열을 사용하다보면 하나의 선언을 통해서 둘 이상의 변수를 선언할 수 있다.
  - 단순히 다수의 변수 선언을 의미하는 것이 아니라, 다수의 변수로는 하기 힘든 작업을 배열을 활용해 쉽게 할 수 있다.



#### 1차원 배열

- 1차원 배열의 선언

  - 별도의 선언 방법이 없으면 변수에 처음 값을 할당할 때 생성

  - 이름: 프로그램에서 사용할 배열의 이름

    `Arr = list()`  	`Arr = []` (1차원 배열 선언의 예)

    

- 1차원 배열의 접근

  - Arr[0] = 10; //'배열 Arr의 0번째 원소에 10을 저장하라'

  - Arr[idx] = 20; // '배열 Arr의 idx번째 원소에 20을 저장하라'

    

- 2차원 배열

  - num = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] ; // 리스트 안에 리스트

    ![](https://t1.daumcdn.net/cfile/tistory/1940B00D4AD1EFB122)

### 연습문제1

- 배열 활용 예제: Gravity

  link = https://swexpertacademy.com/main/learn/course/lectureHtmlViewer.do#none



### 연습문제 2

#### Baby-gin Game

​	link = https://swexpertacademy.com/main/learn/course/lectureHtmlViewer.do

![](C:\Users\multicampus\lecture\image-20200128103422100.png)



> 완전 검색

- 완전 검색 방법은 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법이다.
- Brute-force 혹은 Generate-and-test 기법이라고 불리운다.
- 모든 경우의 수를 테스트한 후, 최종 해법을 도출한다.
- 일반적으로 경우의 수가 작을 때 유용하다.



>완전 검색으로 시작하라

- 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만 해답을 찾아내지 못할 확률은 작다.
- 자격검정평가 등에서 주어진 문제를 풀 때, 우선 완전 검색으로 접근하여 해답을 도출한 후, 다른 알고리즘을 통해 접근하는 것이 바람직하다.



> 순열을 어떻게 생성할 것인가?

- 순열(Permutation)

  - 서로 다른 것들 중 몇 개를 뽑아서 한줄로 나열하는 것
  - 서로 다른 n개 중 r개를 택하는 순열은 아래와 같이 표현한다.

  <center>nPr</center>

  - {1,2,3}을 포함하는 모든 순열을 생성하는 함수
    - 동일한 숫자가 포함되지 않았을 때, 각 자리 수별로 loop를 이용

  ```python
  for i1 in range(1, 4):
      for i2 in range(1, 4):
          if i2 != i1:
              for i3 in range(1, 4):
                  if i3 != i1 and i3 != i2:
                      print(i1, i2, i3)
  ```



#### 탐욕 알고리즘

- 탐욕 알고리즘은 최적해를 구하는 데 사용되는 근시안적인 방법
- 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다.
- 각 선택의 시점에서 이루어지는 결정은 지역적으로 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장은 없다.
- 일반적으로, 머릿속에 떠오르는 생각을 검증 없이 바로 구현하면  Greedy  접근이 된다.
- 완전 검색보다는 성능이 좋지만, 경우에 따라 답이 안나오기도 함.



#### 탐욕 알고리즘의 동작 과정

​	1) 해 선택: 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분해 집합에 추가

​	2) 실행 가능성 검사: 새로운 부분해 집합이 적절한지 검사한다. 곧, 문제의 제약 조건을 위반하지 않는지를 									   검사한다.

​	3) 해 검사: 새로운 부분해 집합이 문제의 해가 되는지 검사한다. 아직 문제의 해가 완성되지 않았다면 1번 						해 선택부터 다시 시작한다.



#### 탐욕 알고리즘의 예

- 거스름돈 줄이기

  - '어떻게 하면 손님에게 거스름돈으로 주는 지폐와 동전의 개수를 최소한으로 줄일 수 있을까?'

    

#### 탐욕 알고리즘 풀이

##### 	Baby gin 구현 예시

```python
num  = int(input("6자리 숫자를 입력하시오: ")) #Baby Gin 확인할 6자리 수 문자열
c = [0] * 12 #6자리 수로부터 각 자리수를 추출하여 개수를 누적할 리스트
for i in range(6):
    c[num % 10] += 1
    num //= 10

i = 0
tri = run = 0
while i < 10 :
    if c[i] >= 3: #triplet 조사 후 데이터 삭제
        c[i] -= 3
        tri += 1
        continue; #다시 while로 돌아감
    if c[i] >= 1 and c[i+1] >= 1 and c [i+2] >=1: #run 조사 후 데이터 삭제
        c[i] -= 1
        c[i+1] -= 1
        c[i+2] -= 1
        run += 1
        continue
    i += 1

if run + tri == 2 :
    print("Baby Gin")
else:
    print("Not Baby Gin")
```



## 3. 정렬



- 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값(오름차순 : ascending), 혹은 그 반대의 순서대로(내림차순: descending) 재배열하는 것

- **키**
  - 자료를 정렬하는 기준이 되는 특정값

- 대표적인 정렬 방식의 종류

  - 버블 정렬

  - 카운팅 정렬

  - 선택 정렬

  - 퀵 정렬

  - 삽입 정렬

  - **병합 정렬** #최근들어 주목받음

    - 퀵정렬, 병합정렬이 성능이 다른 정렬에 비해 좋은 편/ 퀵 정렬은 최악의 경우 n² 만큼의 성능을 보임(입력데이터의 영향을 받는편) 병합 정렬은 입력데이터에 상관없이 최악의 경우에도 *n*log²*n* 만큼의 성능

    - 팀  sort 방식: 삽입 정렬, 병합 정렬(발전된 양식)

      

- APS 과정을 통해 자료구조와 알고리즘을 학스바면서 다양한 형태의 정렬을 학습하게 된다.

- 정렬 알고리즘 시간복잡도 비교

  ![](https://gmlwjd9405.github.io/images/algorithm-bubble-sort/sort-time-complexity.png)



### 버블 정렬(Bubble Sort)

> 알고리즘 기법 - 비교와 교환
>
> 코딩이 가장 손쉬움



- 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
- 정렬 과정
  - 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동한다.
  - 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다.
  - 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양과 같다고 하여 버블 정렬이라고 한다.
- 시간 복잡도
  - O(n²)



#### 버블 정렬 과정

![](https://gmlwjd9405.github.io/images/algorithm-bubble-sort/bubble-sort.png)



- 배열을 활용한 버블 정렬

  

  ```python
  def BubbleSort(a) :
      for i in range(len(a)-1, 0, -1): #범위의 끝 위치
          for j in range(0, i):
              if a [j] > a[j+1]:
                  a[j], a[j+1] = a[j+1], a[j]
      return a
  a = [79, 80, 7, 56, 41]
  print(BubbleSort(a))
  ```





### 카운팅 정렬(Counting Sort)

> 알고리즘 기법: 비교환 방식
>
> n이 비교적 작을 때만 가능하다.



- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘

  

- 제한 사항

  - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능: 각 항목의 발생 횟수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문이다.

  - 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 한다.

    

- 시간 복잡도

  - *O*(*n*+*k*) : n은 리스트 길이, k는 정수의 최대값



![](http://mblogthumb2.phinf.naver.net/MjAxOTAxMTBfMjEx/MDAxNTQ3MTAzOTA1Nzg2.cJCJHkFohEkbBbb9ui7eEzbU23wLuAiMsq0t6sW0JXMg.IrCe0PMNOhUgcCbICVtbjw5VxlYZj6zdCtV96_-25vMg.PNG.dnpc7848/sort5.PNG?type=w800)



#### 카운팅 정렬 알고리즘

> 같은 숫자라도 정렬할 때 순서가 섞이지 않는 **안정 정렬**입니다.

